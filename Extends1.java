
/* 
重载（Overloading）是指在同一个类中定义多个方法，它们具有相同的名称，但是参数列表不同。重载方法的目的是为了提供不同的参数类型和数量，以便于灵活调用。在调用重载方法时，Java编译器会根据实际传递的参数类型和数量来确定调用哪个方法。

o 多态（Polymorphism）是指同一方法可以在  不同的类中  具有不同的实现。在Java中，多态性通常通过继承和方法覆盖来实现。当一个方法被覆盖时，它可以在父类和子类中有不同的实现，这样就可以在运行时选择不同的方法实现。在Java中，通过使用父类引用来调用子类对象的方法，就可以实现多态性。
覆盖（Override）是指在子类中重新定义一个与父类中方法名称、返回类型和参数列表都相同的方法。子类中的方法会覆盖父类中的方法，从而实现自己特定的行为。在调用覆盖方法时，Java编译器会根据实际的对象类型来决定调用哪个方法实现。这种行为被称为动态绑定（Dynamic Binding）或者运行时绑定（Run-time Binding）。
*/
// p ======================================= 继承和多态 
// 继承是指一个类可以继承另一个类的属性和方法。被继承的类称为父类或基类，继承的类称为子类或派生类。
// 子类可以继承父类的属性和方法，也可以通过重写（覆盖）父类的方法来实现自己的功能。
// 多态是面向对象编程中的一个重要概念，它允许不同的对象对同一个消息作出不同的响应。
// 多态的实现需要满足两个条件：继承和方法重写。
// p --------------------------------------子类
/**
 * b "is
 * a"关系是面向对象编程中的一个基本概念，用于描述一个类与另一个类之间的继承关系。如果类A继承自类B，我们就可以说"A是B"，也就是说A具有B的所有属性和方法，同时还可以添加自己的属性和方法。
 * "is a"关系是一种非常基础的关系，它是面向对象编程中实现多态性的基础。通过使用"is
 * a"关系，我们可以将对象看作是它们所属的类的实例，也可以将它们看作是它们的超类的实例。
 */
// b -----------------extends 用于实现继承关系的关键字，它可以用来创建一个类的子类，让子类继承父类的属性和方法。
// w 修饰符 class SubClass(子) extends SuperClass(父) {}
// SubClass表示子类，SuperClass表示父类。通过extends关键字，SubClass可以继承SuperClass中的所有非私有属性和方法，包括public、protected和默认访问权限的成员。子类可以根据需要重写父类中的方法，并且还可以添加自己的属性和方法。前提是这些属性和方法的访问权限是public或protected。
// Java中只支持单继承，也就是说一个类只能有一个直接父类。但是，一个类可以实现多个接口，从而达到类似多继承的效果。
// b ----------------在Java中，Object类 是所有类的根类，所有的类都直接或间接继承自Object类。
// Object类中定义了许多Java中常用的方法，这些方法可以被所有的子类继承和使用
// 常用的Object类方法：
// o equals(obj) / ==方法：比较两个对象是否相等。比较的是对象的引用地址，返回一个布尔
// 如果需要比较对象的属性值，就需要重写equals()方法。
// no hashCode()方法：返回对象的哈希码值。哈希码值可以用于将对象存储在哈希表中。
// o toString()方法：返回对象的字符串表示形式
// 是本身的有关信息。返回的是对象的类名和哈希码值，如果需要返回对象的属性值，就需要重写toString()方法。
// o getClass()方法：返回对象的类对象 即所属类信息。
// wait()、notify()和notifyAll()方法：这些方法用于控制线程的同步和通信，需要在多线程环境下使用。
// no clone()方法：返回对象的副本，可以用于实现对象的复制。
// finalize()方法：在对象被垃圾回收之前调用，可以用于执行一些清理操作。

// b ---------------------------- 单重继承
// o 单重继承指的是一个子类只能继承一个父类的特性。也就是说，在一个类中，只能使用一个extends关键字来继承一个父类，而不能同时继承多个类。
// 这与多重继承不同，多重继承允许一个子类同时继承多个父类的特性。

// 单重继承是Java面向对象编程中的一个基本特性，它可以避免由多重继承带来的复杂性和歧义性，使得代码更加简单和易于维护。在Java中，可以通过接口(interface)来实现类似多重继承的功能，接口允许一个类实现多个接口的特性。这种方式比多重继承更加灵活和安全，可以有效地避免多重继承带来的问题。
// r 子类并不会直接继承父类的构造方法代码，而是通过调用父类的构造方法来完成父类的初始化操作。使用super关键字来调用父类的构造方法，

// b -----------------------------对象转型
// 对象转型（Object Casting）是将一个对象类型转换为另一个对象类型的过程。
// o 在面向对象编程中，对象转型通常发生在继承关系中，即将子类对象转换为父类对象或者将父类对象转换为子类对象。

// 对象转型分为向上转型（Upcasting）和向下转型（Downcasting）两种。
// o 向上转型是将子类对象转换为父类对象，可以隐式地进行，无需显式地调用任何方法。而向下转型是将父类对象转换为子类对象，需要显式地调用强制类型转换符（例如：
// r Subclass obj =(Subclass)superclassObj
// o 并且需要在运行时确保该父类对象实际上是子类对象，否则会抛出ClassCastException异常。
// ;向下转型是一种比较危险的操作，因此应该尽量避免使用向下转型

// o 运算符 object instanceof class
// object是要检查的对象，class是要检查的类。如果object是class的实例或其子类的实例，则返回true

// p 方法覆盖与多态
// 方法覆盖是指在子类中定义一个与父类中具有相同名称和参数列表的方法，从而覆盖父类中的方法实现。当子类对象调用该方法时，会优先调用子类中的方法，而不是父类中的方法。
// 多态是指同一种类型的对象，在不同的情况下会表现出不同的行为。在Java中，多态的实现通常是通过方法覆盖和向上转型来实现的。

// b ----------------------------------方法覆盖
// o 覆盖方法必须具有与被覆盖方法相同的方法签名 子类定义了一个与父类方法名称、返回类型和参数列表相同的方法，从而覆盖了父类中的方法。
// o 覆盖方法的访问修饰符不能比被覆盖方法的访问修饰符更严格。
// o 子类方法不能抛出比父类方法更多的异常，可以不抛出异常或者抛出相同的异常。
// o 子类方法不能覆盖父类中的final方法，final方法是不能被重写的。

// 在运行时，当通过父类引用调用覆盖方法时，实际上执行的是子类中定义的方法。这种行为被称为多态性（Polymorphism），它允许在运行时选择要执行的方法。
// b super()调用父类构造方法
// o super.用于在子类中可以引用父类的成员变量和方法。
// r super()子类构造方法中用于调用父类构造函数的关键字，在子类的构造方法的第一行使用
// g 子类中定义了构造方法 必须在构造方法中使用super()关键字显式地调用父类构造方法，或省略super关键字调用父类的无参构造方法。
// 当创建子类对象时，Java会自动调用父类的无参构造方法，如果父类没有无参构造方法，或者希望使用父类中的其他构造方法来初始化子类对象，就需要使用super关键字显式地调用父类构造方法。
// 父类对象的初始化是在子类对象初始化之前的。当创建一个子类对象时，Java会先调用父类的构造方法来初始化父类对象，然后再调用子类的构造方法来初始化子类对象。如果不先初始化父类对象，那么子类就无法使用父类中定义的实例变量和方法。因此，Java规定必须先初始化父类对象，再初始化子类对象。

// b --------------------------多态
// o 多态是面向对象编程中的一个重要概念，它指的是同一类型的对象，在不同的情况下会表现出不同的行为。具体来说，多态包括编译时多态和运行时多态两种形式。
// g 静态绑定/编译时多态是指在编译时就能确定调用哪个方法，它通常与方法的重载相关。例如，如果一个类中定义了多个同名方法但参数类型或数量不同，
// g 动态绑定/运行时多态是指在程序运行时才能确定调用哪个方法，它通常与方法的覆盖相关。例如，如果一个父类和一个子类都有同名的方法，且子类重写了父类的方法，

// p -------------------------------终极类与抽象类
// b ----------------------------final类
// o final 类不能包含抽象方法或抽象方法块，也不能被继承或包含私有方法，类中的静态变量和静态方法也不能修改，只能 new 关键字来创建实例。
// g final 类通常被用于实现封装性 final 类不能被继承，因此可以保证该类中的方法和属性不会被其他类误用或修改。
// g final 类还可以用于实现最终方法，这些方法通常是一些重要的公共方法，需要在整个应用程序中被调用。

// b ----------------------------final方法 不能被子类重写，也不能被修改。

// b final变量 在初始化后不能再被赋值，如果是基本类型的变量，其数值不能改变；如果是引用类型的变量，其指向的对象不能改变，但对象的内容可以改变
// g final 变量经常和 static 关键字一起使用，作为类常量

// p 抽象类
// b ------------------------------抽象类是指包含一个或多个抽象方法的类。抽象方法是指没有具体实现的方法，只有声明。
// r 抽象类不能被实例化，只能被继承。抽象类的目的是为了提供一个可以继承的通用的基类，描述了类的行为和功能，而不需要完成类的特定实现。
// o 抽象类可以包含普通的成员变量和成员方法，也可以包含构造方法。如果一个类继承了一个抽象类，那么它必须实现所有的抽象方法，否则它也必须被声明为抽象类。
// r 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
// p -------------接口
// b -------------接口 interface
// Java接口是一种抽象类型，是一组抽象方法的集合，通常用interface关键字来声明。一个类可以通过实现接口的方式来继承接口的抽象方法。接口不是类，不能被实例化，但可以被实现。一个实现接口的类必须实现接口中所有的方法，否则必须声明为抽象类。一个类可以实现多个接口，一个接口也可以继承另一个接口。
// o 接口使用 interface 声明，可以有可见修饰符（如public）和extends关键字（用于继承其他接口）。
// r 接口中的属性必须是public static final 公共 静态终极类型的常量，可以省略这些修饰符，默认为常量，必须赋初始值且不能更改。
// r 接口中的方法必须是public abstract 公共 类型的，可以省略这些修饰符，
// o 默认为抽象方法无方法体，除非使用default或static（Java 8及以上）或private（Java 9及以上）修饰，这些方法可以有方法体。
// r 接口不能有构造方法，不能用于实例化对象，但可以声明引用变量，指向实现接口的类的对象。
// o 接口可以被类实现，使用 implements 一个类可以实现多个接口，用逗号分隔。实现接口的类必须实现接口中所有的抽象方法，否则必须声明为抽象类。
// w [可见修饰符] interface 接口名 [extends 父接口名,--,--] { 声明变量; 抽象方法; }

// b ------------实现接口 implements
// o 类使用implements关键字来实现一个或多个接口，可以在extends关键字之后使用。
// 类的名称应该遵循类名的命名规则，一般以大写字母开头，由多个有意义的单词组成。
// 类可以有自己的属性和构造方法，也可以继承父类的属性和构造方法。
// o 类必须重写接口中的所有抽象方法，除非该类是抽象类。重写的方法必须保持一致的方法名、参数列表和返回值类型，并且不能抛出比接口中更强制性的异常。
// o 类可以重写接口中的默认方法、静态方法和私有方法，也可以直接调用它们。
// o 类可以实现多个接口，如果多个接口中有相同的默认方法或常量，那么类必须解决冲突，例如通过指定接口名来调用默认方法或常量。
// w public class 接口名[extends superclass] implements 父接口,--,--{ }
/**
 * 而父类和接口中有同名的方法，那么子类应该如何区分和调用这些方法。这个问题的答案取决于父类和接口中的方法是什么类型的方法，例如：
 * 
 *g 如果父类和接口中的方法都是静态方法，那么子类可以直接通过父类名或者接口名来调用它们，不会产生冲突。例如，Father.hobby()或者InterfaceA.hobby()。
 *g 如果父类和接口中的方法都是非静态方法，那么子类需要重写这些方法，否则会产生编译错误。子类重写的方法会覆盖父类和接口中的同名方法。
 * 或者子类想要调用父类或者接口中的原始方法，可以使用super或者 接口名.super来指定。例如，super.drink()或者InterfaceA.super.drink()。
 *g 如果父类和接口中的方法有一个是静态的，另一个是非静态的，那么子类可以直接通过父类名或者接口名来调用静态方法，也可以直接调用非静态方法。
 * 或者子类想要重写非静态方法，可以自由选择是否覆盖父类或者接口中的同名方法。例如，Father.hobby()或者InterfaceA.hobby()，以及drink()或者InterfaceA.super.drink()。
 */
public class Extends1 {
    public static void main(String[] args) {
        Animal animal1 = new Animal();// 爹对象 自动调用了animal构造器
        Animal animal2 = new Cat();// 子对象上转型 自动调用了cat构造器

        Cat cat = (Cat) animal2;// 下转型
        System.out.print("\nCat cat = (Cat) animal2;下转型");
        cat.Sound();// 子方法

        System.out.print("cat.equals(animali2)比较是否同一个对象 " + cat.equals(animal2));// 比较
        animal1.Sound(); // 父方法

        System.out.print("animal1.getClass()获取类对象" + animal1.getClass());// o 可以加上Class 对象的 getName() / toString()
        animal2.Sound();// 多态-覆盖

        System.out.println("animal2.getClass()获取类对象" + animal2.getClass());//
        System.out.println("(animal2 instanceof Animal) 实例所属类检查" + (animal2 instanceof Animal));
        Rect rect = new Rect(10, 20);// 创建抽象类子类对象

        System.out.println("abstract 抽象类" + rect.getArea() + Shape.setColor(" Blue "));// 先运行了setcolor 然后输出返回值
        Dog dog = new Dog();// y 创建接口子类对象
        dog.Sound();
    }

}

class Animal {
    public Animal() {
        System.out.println("super() 调用父类构造器 ");
    }

    public void Sound() {
        System.out.println(" 父类animal叫");
    }

    public void method() {
        System.out.println("super.method()调用父类方法");
    }
}

class Cat extends Animal {
    public Cat() {
        super();// super()调用父类构造器
        System.out.println("super()/super(参数)");
    }

    public void Sound() {

        super.method();// super.调用父类方法
        System.out.println(" 子类猫猫叫");
    }

}

// y extends 继承 animal类和dog 接口 implements
class Dog extends Animal implements Dogif {
    public void Sound() {
        System.out.println(" 子类修勾也叫"+name);
    }
}

// b ----------------------------------定义一个抽象类 Shape
abstract class Shape {
    private static String color;

    public static String setColor(String color1) {
        Shape.color = color1;// 将参数color的值赋给当前对象的私有成员变量color
        System.out.print(color);
        return " 返回值" + color;
    }

    // 定义一个抽象方法 getArea
    public abstract double getArea();
}

// 定义一个继承自 Shape 的子类 Rect
class Rect extends Shape {
    // 定义两个私有的成员变量
    private double length;
    private double width;

    // 定义一个构造方法
    public Rect(double length, double width) {
        this.length = length;
        this.width = width;
    }

    // 实现父类的抽象方法 getArea
    public double getArea() {
        return length * width;
    }
}

// b ---------------------接口interface / implements
interface Dogif {
    public static final String name = "修勾的修勾";//默认static final 可省略

    void Sound();// 公共抽象方法

}