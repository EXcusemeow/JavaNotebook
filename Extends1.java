
/* 
重载（Overloading）是指在同一个类中定义多个方法，它们具有相同的名称，但是参数列表不同。重载方法的目的是为了提供不同的参数类型和数量，以便于灵活调用。在调用重载方法时，Java编译器会根据实际传递的参数类型和数量来确定调用哪个方法。

o 多态（Polymorphism）是指同一方法可以在  不同的类中  具有不同的实现。在Java中，多态性通常通过继承和方法覆盖来实现。当一个方法被覆盖时，它可以在父类和子类中有不同的实现，这样就可以在运行时选择不同的方法实现。在Java中，通过使用父类引用来调用子类对象的方法，就可以实现多态性。
覆盖（Override）是指在子类中重新定义一个与父类中方法名称、返回类型和参数列表都相同的方法。子类中的方法会覆盖父类中的方法，从而实现自己特定的行为。在调用覆盖方法时，Java编译器会根据实际的对象类型来决定调用哪个方法实现。这种行为被称为动态绑定（Dynamic Binding）或者运行时绑定（Run-time Binding）。
*/
// p ======================================= 继承和多态 
// 继承是指一个类可以继承另一个类的属性和方法。被继承的类称为父类或基类，继承的类称为子类或派生类。
// 子类可以继承父类的属性和方法，也可以通过重写（覆盖）父类的方法来实现自己的功能。
// 多态是面向对象编程中的一个重要概念，它允许不同的对象对同一个消息作出不同的响应。
// 多态的实现需要满足两个条件：继承和方法重写。
// p --------------------------------------子类
/**
 * b "is
 * a"关系是面向对象编程中的一个基本概念，用于描述一个类与另一个类之间的继承关系。如果类A继承自类B，我们就可以说"A是B"，也就是说A具有B的所有属性和方法，同时还可以添加自己的属性和方法。
 * "is a"关系是一种非常基础的关系，它是面向对象编程中实现多态性的基础。通过使用"is
 * a"关系，我们可以将对象看作是它们所属的类的实例，也可以将它们看作是它们的超类的实例。
 */
// b -----------------extends 用于实现继承关系的关键字，它可以用来创建一个类的子类，让子类继承父类的属性和方法。
// w 修饰符 class SubClass(子) extends SuperClass(父) {}
// SubClass表示子类，SuperClass表示父类。通过extends关键字，SubClass可以继承SuperClass中的所有非私有属性和方法，包括public、protected和默认访问权限的成员。子类可以根据需要重写父类中的方法，并且还可以添加自己的属性和方法。前提是这些属性和方法的访问权限是public或protected。
// Java中只支持单继承，也就是说一个类只能有一个直接父类。但是，一个类可以实现多个接口，从而达到类似多继承的效果。
// b ----------------在Java中，Object类 是所有类的根类，所有的类都直接或间接继承自Object类。
// Object类中定义了许多Java中常用的方法，这些方法可以被所有的子类继承和使用
// 常用的Object类方法：
// o equals(obj) / ==方法：比较两个对象是否相等。比较的是对象的引用地址，返回一个布尔
// 如果需要比较对象的属性值，就需要重写equals()方法。
// no hashCode()方法：返回对象的哈希码值。哈希码值可以用于将对象存储在哈希表中。
// o toString()方法：返回对象的字符串表示形式
// 是本身的有关信息。返回的是对象的类名和哈希码值，如果需要返回对象的属性值，就需要重写toString()方法。
// o getClass()方法：返回对象的类对象 即所属类信息。
// wait()、notify()和notifyAll()方法：这些方法用于控制线程的同步和通信，需要在多线程环境下使用。
// no clone()方法：返回对象的副本，可以用于实现对象的复制。
// finalize()方法：在对象被垃圾回收之前调用，可以用于执行一些清理操作。

// b ---------------------------- 单重继承
// o 单重继承指的是一个子类只能继承一个父类的特性。也就是说，在一个类中，只能使用一个extends关键字来继承一个父类，而不能同时继承多个类。
// 这与多重继承不同，多重继承允许一个子类同时继承多个父类的特性。

// 单重继承是Java面向对象编程中的一个基本特性，它可以避免由多重继承带来的复杂性和歧义性，使得代码更加简单和易于维护。在Java中，可以通过接口(interface)来实现类似多重继承的功能，接口允许一个类实现多个接口的特性。这种方式比多重继承更加灵活和安全，可以有效地避免多重继承带来的问题。
// r 子类并不会直接继承父类的构造方法代码，而是通过调用父类的构造方法来完成父类的初始化操作。使用super关键字来调用父类的构造方法，

// b -----------------------------对象转型
// 对象转型（Object Casting）是将一个对象类型转换为另一个对象类型的过程。
// o 在面向对象编程中，对象转型通常发生在继承关系中，即将子类对象转换为父类对象或者将父类对象转换为子类对象。

// 对象转型分为向上转型（Upcasting）和向下转型（Downcasting）两种。
// o 向上转型是将子类对象转换为父类对象，可以隐式地进行，无需显式地调用任何方法。而向下转型是将父类对象转换为子类对象，需要显式地调用强制类型转换符（例如：
// r Subclass obj =(Subclass)superclassObj
// o 并且需要在运行时确保该父类对象实际上是子类对象，否则会抛出ClassCastException异常。
// ;向下转型是一种比较危险的操作，因此应该尽量避免使用向下转型

// o 运算符 object instanceof class
// object是要检查的对象，class是要检查的类。如果object是class的实例或其子类的实例，则返回true

// p 方法覆盖与多态
// 方法覆盖是指在子类中定义一个与父类中具有相同名称和参数列表的方法，从而覆盖父类中的方法实现。当子类对象调用该方法时，会优先调用子类中的方法，而不是父类中的方法。
// 多态是指同一种类型的对象，在不同的情况下会表现出不同的行为。在Java中，多态的实现通常是通过方法覆盖和向上转型来实现的。

// b ----------------------------------方法覆盖
// o 覆盖方法必须具有与被覆盖方法相同的方法签名 子类定义了一个与父类方法名称、返回类型和参数列表相同的方法，从而覆盖了父类中的方法。
// o 覆盖方法的访问修饰符不能比被覆盖方法的访问修饰符更严格。
// o 子类方法不能抛出比父类方法更多的异常，可以不抛出异常或者抛出相同的异常。
// o 子类方法不能覆盖父类中的final方法，final方法是不能被重写的。

// 在运行时，当通过父类引用调用覆盖方法时，实际上执行的是子类中定义的方法。这种行为被称为多态性（Polymorphism），它允许在运行时选择要执行的方法。
// b super()调用父类构造方法
// o super.用于在子类中可以引用父类的成员变量和方法。
// r super()子类构造方法中用于调用父类构造函数的关键字，在子类的构造方法的第一行使用
// g 子类中定义了构造方法 必须在构造方法中使用super()关键字显式地调用父类构造方法，或省略super关键字调用父类的无参构造方法。
// 当创建子类对象时，Java会自动调用父类的无参构造方法，如果父类没有无参构造方法，或者希望使用父类中的其他构造方法来初始化子类对象，就需要使用super关键字显式地调用父类构造方法。
// 父类对象的初始化是在子类对象初始化之前的。当创建一个子类对象时，Java会先调用父类的构造方法来初始化父类对象，然后再调用子类的构造方法来初始化子类对象。如果不先初始化父类对象，那么子类就无法使用父类中定义的实例变量和方法。因此，Java规定必须先初始化父类对象，再初始化子类对象。

// b --------------------------多态
// o 多态是面向对象编程中的一个重要概念，它指的是同一类型的对象，在不同的情况下会表现出不同的行为。具体来说，多态包括编译时多态和运行时多态两种形式。
// g 静态绑定/编译时多态是指在编译时就能确定调用哪个方法，它通常与方法的重载相关。例如，如果一个类中定义了多个同名方法但参数类型或数量不同，
// g 动态绑定/运行时多态是指在程序运行时才能确定调用哪个方法，它通常与方法的覆盖相关。例如，如果一个父类和一个子类都有同名的方法，且子类重写了父类的方法，

public class Extends1 {
    public static void main(String[] args) {
        Animal animal1 = new Animal();// 爹对象  自动调用了animal构造器
        Animal animal2 = new Cat();// 子对象上转型 自动调用了cat构造器

        Cat cat = (Cat) animal2;// 下转型
        System.out.print("\nCat cat = (Cat) animal2;下转型");
        cat.Sound();// 子方法

        System.out.print("cat.equals(animali2)比较是否同一个对象 " + cat.equals(animal2));// 比较
        animal1.Sound(); // 父方法

        System.out.print("animal1.getClass()获取类对象" + animal1.getClass());// o 可以加上Class 对象的 getName() / toString()
        animal2.Sound();// 多态-覆盖

        System.out.println("animal2.getClass()获取类对象" + animal2.getClass());//
        System.out.println("(animal2 instanceof Animal) 实例所属类检查" + (animal2 instanceof Animal));
  
    }

}

class Animal {
    public Animal() {
        System.out.println("super() 调用父类构造器 ");
    }

    public void Sound() {
        System.out.println(" 父类animal叫");
    }
public void method(){
    System.out.println("super.method()调用父类方法");
}
}

class Cat extends Animal {
    public Cat() {
        super();//super()调用父类构造器 
        System.out.println("super()/super(参数)");
    }
    public void Sound() {
        
        super.method();// super.调用父类方法
        System.out.println(" 子类猫猫叫");
    }

}

class Dog extends Animal {
    public void Sound() {
        System.out.println(" 子类修勾也叫");
    }
}